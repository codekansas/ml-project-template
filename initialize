#!/usr/bin/env python
"""Runs the project initialization."""

import argparse
import re
import sys
from pathlib import Path
from typing import Callable, cast

# Regex matching valid Python module names.
NAME_REGEX = re.compile(r"^[a-zA-Z_][a-zA-Z0-9_]*$")


def show_success(msg: str) -> None:
    print(f"\033[1;32m{msg}\033[0m")


def show_dry_run(msg: str) -> None:
    print(f"\033[1;33m{msg}\033[0m")


def show_warning(msg: str, bold: bool = False) -> None:
    print(f"\033[{'1;' if bold else ''}31m{msg}\033[0m")


def is_valid_name(name: str) -> bool:
    if NAME_REGEX.match(name) is None:
        show_warning(f"'{name}' is not a valid project name")
        return False
    return True


def read_input(
    prompt: str,
    pre: str | None = None,
    post: str | None = None,
    success_func: Callable[[str], bool] = lambda _: True,
) -> str:
    prompt_str = f"{pre}\033[36m{prompt}\033[0m{post} "
    s = input(prompt_str).strip()
    if s.lower() in ("q", "quit"):
        show_warning("Quitting")
        sys.exit(0)
    while not success_func(s):
        s = input(prompt_str).strip()
        if s.lower() in ("q", "quit"):
            show_warning("Quitting")
            sys.exit(0)
    return s


def read_yes_no(prompt: str, pre: str | None = None) -> bool:
    return read_input(prompt, pre, "? [y/n]", lambda s: s.lower() in ("y", "n")).lower() == "y"


def rename_setup_py(use_cpp: bool, dry_run: bool) -> None:
    # Renames the right setup.py file.
    setup_py_name = "setup_cpp.py" if use_cpp else "setup_no_cpp.py"
    setup_py = Path(__file__).parent.resolve() / setup_py_name
    if setup_py.exists():
        if dry_run:
            show_dry_run(f"Renaming {setup_py_name} to setup.py")
        else:
            setup_py.rename(Path(__file__).parent.resolve() / "setup.py")
    else:
        show_warning(f"Can't find {setup_py_name}")

    # Removes the other setup.py file.
    other_setup_py_name = "setup_no_cpp.py" if use_cpp else "setup_cpp.py"
    other_setup_py = Path(__file__).parent.resolve() / other_setup_py_name
    if other_setup_py.exists():
        if dry_run:
            show_dry_run(f"Removing {other_setup_py_name}")
        else:
            other_setup_py.unlink()
    else:
        show_warning(f"Can't find {other_setup_py_name}")

    # Removes `project/cpp` subdirectory if `use_cpp` is False.
    if not use_cpp:
        cpp_dir = Path(__file__).parent.resolve() / "project" / "cpp"
        if cpp_dir.exists():
            if dry_run:
                show_dry_run("Removing C++ subdirectory")
            else:
                cpp_dir.rmdir()
        else:
            show_warning("Can't find C++ subdirectory")


def rename_project(new_name: str, dry_run: bool) -> None:
    # Renames project root directory.
    root_dir = Path(__file__).parent.resolve()
    if (project_root := root_dir / "project").exists():
        if dry_run:
            show_dry_run(f"Renaming project root to '{new_name}'")
        else:
            project_root.rename(root_dir / new_name)
    else:
        show_warning(f"Can't find project root in {project_root}")

    # Replaces `project.scripts.cli` with `{new_name}.scripts.cli` in `setup.cfg`.
    setup_cfg = root_dir / "setup.cfg"
    if setup_cfg.exists():
        if dry_run:
            show_dry_run("Replacing project name in setup.cfg")
        else:
            with open(setup_cfg, "r", encoding="utf-8") as f:
                setup_cfg_content = f.read()
            setup_cfg_content = setup_cfg_content.replace("project.scripts.cli", f"{new_name}.scripts.cli")
            with open(setup_cfg, "w", encoding="utf-8") as f:
                f.write(setup_cfg_content)
    else:
        show_warning(f"Can't find {setup_cfg}")

    # Replaces PROJECT_NAME = "project" with PROJECT_NAME = "{new_name}" in `setup.py`.
    setup_py = root_dir / "setup.py"
    if setup_py.exists() or dry_run:
        if dry_run:
            show_dry_run("Replacing project name in setup.py")
        else:
            with open(setup_py, "r", encoding="utf-8") as f:
                setup_py_content = f.read()
            setup_py_content = setup_py_content.replace('PROJECT_NAME = "project"', f'PROJECT_NAME = "{new_name}"')
            with open(setup_py, "w", encoding="utf-8") as f:
                f.write(setup_py_content)
    else:
        show_warning(f"Can't find {setup_py}")


def remove_init(remove: bool, dry_run: bool) -> None:
    if not remove:
        return

    init_path = Path(__file__).resolve().relative_to(Path.cwd())
    if dry_run:
        show_warning(f"Removing {init_path}")
    else:
        init_path.unlink()


def main() -> None:
    parser = argparse.ArgumentParser(description="Initializes a new project")
    parser.add_argument("-d", "--dry-run", default=False, action="store_true")
    args = parser.parse_args()

    dry_run = cast(bool, args.dry_run)

    use_cpp = read_yes_no("C++ backend", "Requires ")
    rename_setup_py(use_cpp, dry_run)

    new_name = read_input("project name", "New ", ":", is_valid_name)
    rename_project(new_name, dry_run)

    remove_init(read_yes_no("initialize script", "Remove "), dry_run)

    show_success("Done!")


if __name__ == "__main__":
    main()
